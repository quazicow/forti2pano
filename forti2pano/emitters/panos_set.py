"""PAN-OS set command emitter."""

from typing import List

from ..model.config import PanoConfig
from ..model.objects import AddressType
from ..model.policy import NATType
from ..mappings.services import map_service


def emit_set_commands(config: PanoConfig) -> List[str]:
    """Generate all PAN-OS set commands."""
    commands = []
    commands.append(f"# PAN-OS Set Commands generated by forti2pano")
    commands.append(f"# Source: FortiGate config")
    commands.append("")

    commands.extend(_set_addresses(config))
    commands.extend(_set_address_groups(config))
    commands.extend(_set_services(config))
    commands.extend(_set_service_groups(config))
    commands.extend(_set_zones(config))
    commands.extend(_set_interfaces(config))
    commands.extend(_set_virtual_router(config))
    commands.extend(_set_security_rules(config))
    commands.extend(_set_nat_rules(config))
    commands.extend(_set_ike_crypto(config))
    commands.extend(_set_ipsec_crypto(config))
    commands.extend(_set_ike_gateways(config))
    commands.extend(_set_ipsec_tunnels(config))

    return commands


def emit_set_commands_string(config: PanoConfig) -> str:
    """Return set commands as a single string."""
    return "\n".join(emit_set_commands(config))


def _q(value: str) -> str:
    """Quote a value if it contains spaces."""
    if " " in value or not value:
        return f'"{value}"'
    return value


def _member_list(items: List[str]) -> str:
    """Format a member list for set commands: [val1 val2 val3]."""
    return "[" + " ".join(_q(i) for i in items) + "]"


def _set_addresses(config: PanoConfig) -> List[str]:
    if not config.addresses:
        return []
    cmds = ["", "# Address Objects"]
    for addr in config.addresses:
        p = f"set address {_q(addr.name)}"
        if addr.addr_type == AddressType.IP_NETMASK:
            cmds.append(f"{p} ip-netmask {addr.value}")
        elif addr.addr_type == AddressType.IP_RANGE:
            cmds.append(f"{p} ip-range {addr.value}")
        elif addr.addr_type == AddressType.FQDN:
            cmds.append(f"{p} fqdn {addr.value}")
        elif addr.addr_type == AddressType.IP_WILDCARD:
            cmds.append(f"{p} ip-wildcard {addr.value}")
        if addr.description:
            cmds.append(f'{p} description "{addr.description}"')
    return cmds


def _set_address_groups(config: PanoConfig) -> List[str]:
    if not config.address_groups:
        return []
    cmds = ["", "# Address Groups"]
    for grp in config.address_groups:
        p = f"set address-group {_q(grp.name)}"
        cmds.append(f"{p} static {_member_list(grp.members)}")
        if grp.description:
            cmds.append(f'{p} description "{grp.description}"')
    return cmds


def _set_services(config: PanoConfig) -> List[str]:
    if not config.services:
        return []
    cmds = ["", "# Service Objects"]
    for svc in config.services:
        p = f"set service {_q(svc.name)}"
        if svc.protocol in ("tcp", "udp"):
            cmds.append(f"{p} protocol {svc.protocol} port {svc.dst_port}")
            if svc.src_port:
                cmds.append(f"{p} protocol {svc.protocol} source-port {svc.src_port}")
        elif svc.protocol == "icmp":
            cmds.append(f"# {svc.name}: ICMP service (type={svc.icmp_type})")
        elif svc.protocol == "ip" and svc.protocol_number:
            cmds.append(f"# {svc.name}: IP protocol {svc.protocol_number}")
        if svc.description:
            cmds.append(f'{p} description "{svc.description}"')
    return cmds


def _set_service_groups(config: PanoConfig) -> List[str]:
    if not config.service_groups:
        return []
    cmds = ["", "# Service Groups"]
    for grp in config.service_groups:
        cmds.append(f"set service-group {_q(grp.name)} members {_member_list(grp.members)}")
    return cmds


def _set_zones(config: PanoConfig) -> List[str]:
    if not config.zones:
        return []
    cmds = ["", "# Zones"]
    for zone in config.zones:
        intfs = zone.interfaces_panos if zone.interfaces_panos else zone.interfaces_fg
        for intf in intfs:
            cmds.append(f"set zone {_q(zone.name)} network layer3 {_member_list([intf])}")
    return cmds


def _set_interfaces(config: PanoConfig) -> List[str]:
    cmds = ["", "# Interfaces"]
    for iface in config.interfaces:
        panos_name = iface.panos_name or iface.fg_name
        if not panos_name.startswith("ethernet"):
            continue
        if iface.ip_address:
            cmds.append(f"set network interface ethernet {_q(panos_name)} layer3 ip {iface.ip_address}")

    # Tunnel interfaces from VPN
    for p1 in config.phase1_list:
        if p1.interface_panos and p1.interface_panos.startswith("tunnel."):
            cmds.append(f"set network interface tunnel units {_q(p1.interface_panos)}")

    return cmds


def _set_virtual_router(config: PanoConfig) -> List[str]:
    cmds = ["", "# Virtual Router and Static Routes"]
    vr = config.virtual_router

    # Add interfaces to virtual router
    for iface in config.interfaces:
        name = iface.panos_name or iface.fg_name
        cmds.append(f"set network virtual-router {_q(vr)} interface {name}")

    for route in config.static_routes:
        p = f"set network virtual-router {_q(vr)} routing-table ip static-route {_q(route.name)}"
        cmds.append(f"{p} destination {route.destination}")
        if route.nexthop:
            cmds.append(f"{p} nexthop ip-address {route.nexthop}")
        intf = route.interface_panos or route.interface_fg
        if intf:
            cmds.append(f"{p} interface {intf}")
        if route.distance != 10:
            cmds.append(f"{p} metric {route.distance}")

    return cmds


def _set_security_rules(config: PanoConfig) -> List[str]:
    if not config.security_policies:
        return []
    cmds = ["", "# Security Rules"]
    for pol in config.security_policies:
        p = f"set rulebase security rules {_q(pol.name)}"
        cmds.append(f"{p} from {_member_list(pol.source_zones or ['any'])}")
        cmds.append(f"{p} to {_member_list(pol.dest_zones or ['any'])}")
        cmds.append(f"{p} source {_member_list(pol.source_addresses or ['any'])}")
        cmds.append(f"{p} destination {_member_list(pol.dest_addresses or ['any'])}")

        if pol.source_negate:
            cmds.append(f"{p} negate-source yes")
        if pol.dest_negate:
            cmds.append(f"{p} negate-destination yes")

        # Map services
        mapped = [map_service(s) for s in pol.services]
        cmds.append(f"{p} service {_member_list(mapped or ['application-default'])}")
        cmds.append(f"{p} application {_member_list(pol.application or ['any'])}")
        cmds.append(f"{p} action {pol.action}")

        if pol.log_start:
            cmds.append(f"{p} log-start yes")
        if pol.log_end:
            cmds.append(f"{p} log-end yes")

        # Security profiles
        if pol.profile_group:
            cmds.append(f"{p} profile-setting group {_q(pol.profile_group)}")
        else:
            if pol.av_profile:
                cmds.append(f"{p} profile-setting profiles virus {_member_list([pol.av_profile])}")
            if pol.vulnerability_profile:
                cmds.append(f"{p} profile-setting profiles vulnerability {_member_list([pol.vulnerability_profile])}")
            if pol.url_filter_profile:
                cmds.append(f"{p} profile-setting profiles url-filtering {_member_list([pol.url_filter_profile])}")
            if pol.file_blocking_profile:
                cmds.append(f"{p} profile-setting profiles file-blocking {_member_list([pol.file_blocking_profile])}")
            if pol.spyware_profile:
                cmds.append(f"{p} profile-setting profiles spyware {_member_list([pol.spyware_profile])}")
            if pol.wildfire_profile:
                cmds.append(f"{p} profile-setting profiles wildfire-analysis {_member_list([pol.wildfire_profile])}")

        if not pol.enabled:
            cmds.append(f"{p} disabled yes")

        if pol.description:
            cmds.append(f'{p} description "{pol.description}"')

    return cmds


def _set_nat_rules(config: PanoConfig) -> List[str]:
    if not config.nat_policies:
        return []
    cmds = ["", "# NAT Rules"]
    for nat_pol in config.nat_policies:
        p = f"set rulebase nat rules {_q(nat_pol.name)}"
        cmds.append(f"{p} from {_member_list(nat_pol.from_zones or ['any'])}")
        cmds.append(f"{p} to {_member_list(nat_pol.to_zones or ['any'])}")
        cmds.append(f"{p} source {_member_list(nat_pol.source or ['any'])}")
        cmds.append(f"{p} destination {_member_list(nat_pol.destination or ['any'])}")
        cmds.append(f"{p} service {nat_pol.service or 'any'}")

        if nat_pol.nat_type in (NATType.DNAT, NATType.DNAT_PORT_FORWARD):
            if nat_pol.dest_translated_address:
                cmds.append(f"{p} destination-translation translated-address {nat_pol.dest_translated_address}")
                if nat_pol.dest_translated_port:
                    cmds.append(f"{p} destination-translation translated-port {nat_pol.dest_translated_port}")

        elif nat_pol.nat_type in (NATType.SNAT_DYNAMIC, NATType.SNAT_INTERFACE):
            if nat_pol.src_translated_type == "dynamic-ip-and-port":
                if nat_pol.src_translated_addresses:
                    cmds.append(f"{p} source-translation dynamic-ip-and-port translated-address {_member_list(nat_pol.src_translated_addresses)}")
                else:
                    cmds.append(f"{p} source-translation dynamic-ip-and-port interface-address")
            elif nat_pol.src_translated_type == "static-ip":
                if nat_pol.src_translated_addresses:
                    cmds.append(f"{p} source-translation static-ip translated-address {nat_pol.src_translated_addresses[0]}")

        if nat_pol.description:
            cmds.append(f'{p} description "{nat_pol.description}"')

    return cmds


def _set_ike_crypto(config: PanoConfig) -> List[str]:
    if not config.ike_crypto_profiles:
        return []
    cmds = ["", "# IKE Crypto Profiles"]
    for prof in config.ike_crypto_profiles:
        p = f"set network ike crypto-profiles ike-crypto-profiles {_q(prof.name)}"
        cmds.append(f"{p} encryption {_member_list(prof.encryption or ['aes-256-cbc'])}")
        cmds.append(f"{p} hash {_member_list(prof.authentication or ['sha256'])}")
        cmds.append(f"{p} dh-group {_member_list(prof.dh_group or ['group14'])}")
        cmds.append(f"{p} lifetime seconds {prof.lifetime_seconds}")
    return cmds


def _set_ipsec_crypto(config: PanoConfig) -> List[str]:
    if not config.ipsec_crypto_profiles:
        return []
    cmds = ["", "# IPSec Crypto Profiles"]
    for prof in config.ipsec_crypto_profiles:
        p = f"set network ike crypto-profiles ipsec-crypto-profiles {_q(prof.name)}"
        cmds.append(f"{p} esp encryption {_member_list(prof.encryption or ['aes-256-cbc'])}")
        cmds.append(f"{p} esp authentication {_member_list(prof.authentication or ['sha256'])}")
        if prof.dh_group and prof.dh_group != "no-pfs":
            cmds.append(f"{p} dh-group {prof.dh_group}")
        cmds.append(f"{p} lifetime seconds {prof.lifetime_seconds}")
    return cmds


def _set_ike_gateways(config: PanoConfig) -> List[str]:
    if not config.ike_gateways:
        return []
    cmds = ["", "# IKE Gateways"]
    for gw in config.ike_gateways:
        p = f"set network ike gateway {_q(gw.name)}"
        cmds.append(f"{p} peer-address ip {gw.peer_address}")
        if gw.interface:
            cmds.append(f"{p} local-address interface {gw.interface}")
        cmds.append(f"{p} authentication pre-shared-key key {_q(gw.psk)}")
        cmds.append(f"{p} protocol ikev1 ike-crypto-profile {_q(gw.crypto_profile)}")
        if gw.nat_traversal:
            cmds.append(f"{p} protocol-common nat-traversal enable yes")
    return cmds


def _set_ipsec_tunnels(config: PanoConfig) -> List[str]:
    if not config.ipsec_tunnels:
        return []
    cmds = ["", "# IPSec Tunnels"]
    for tun in config.ipsec_tunnels:
        p = f"set network tunnel ipsec {_q(tun.name)}"
        cmds.append(f"{p} auto-key ike-gateway {_q(tun.ike_gateway)}")
        cmds.append(f"{p} auto-key ipsec-crypto-profile {_q(tun.crypto_profile)}")
        if tun.tunnel_interface:
            cmds.append(f"{p} tunnel-interface {tun.tunnel_interface}")
        for pid in tun.proxy_ids:
            pid_name = pid.get("name", "proxy-1")
            pp = f"{p} auto-key proxy-id {_q(pid_name)}"
            if pid.get("local"):
                cmds.append(f"{pp} local {pid['local']}")
            if pid.get("remote"):
                cmds.append(f"{pp} remote {pid['remote']}")
    return cmds
